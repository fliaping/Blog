---
title: "个人专属APP时代到来：零代码打造主机唤醒方案GreenWake（基于Cursor）"
date: 2025-01-08T22:03:23+08:00
draft: false
categories: ["AI之遥"] # Developer AI之遥 科幻Fans 智慧之光 星云尘埃 酷cool玩 读书 随笔
slug: "the-era-of-personal-exclusive-apps-has-arrived-greenwake"
tags: ["AI编码"]
author: "Payne Xu"

---


## 引言

![1736322251337](https://fliaping-blog.oss-rg-china-mainland.aliyuncs.com/storage/2025-01-08/22-12/1736322251337.gif)

![1736322264573](https://fliaping-blog.oss-rg-china-mainland.aliyuncs.com/storage/2025-01-08/22-12/1736322264573.gif)

还记得《流浪地球2》里那个酷炫的场面吗？550W量子计算机生成了制造月球发动机的操作系统，当时觉得到这个场景的实现还是很难的，两年后我的看法已经发生了很大变化，利用AI编程助手已经可以"整一些花活"了！🤖 虽然还比不上550W那么逆天，但像Cursor这样的AI工具已经能帮我们写代码、改bug、 甚至很多不懂的代码人也可以用Cursor来做一个应用。从"Hello World"到"Hello AI"，编程这件事儿正在变得越来越平民化~

接下来，就让我们一起看看，这个Cursor到底有多能打！💪 我们会通过一个实战项目，看看它们是真·未来科技，还是只会"整活"的"人工智障"。（温馨提示：本文可能会让你对未来的编程工作充满期待，也可能会让你担心被AI抢饭碗，请系好安全带，谨慎阅读~）

## 项目简介

这个需求源于真实的场景，家里有一个台式电脑，用来打打3A大作，跑跑7B-int4量化模型， 用用Windows专属应用，由于家里就这一台Windows设备，不在家的情况下需要用Windows平台时要通过远程桌面连接，但电脑一直开机的话，平均100瓦的功率，一个月下来电费也是够我喝几杯奶茶了，最重要是不环保，所以就使用了远程唤醒的方案，一般路由器上有唤醒的功能，使用时打开路由器页面操作唤醒，不用时在远程桌面点击睡眠，但这样非常不方便，尤其对于我老婆这种电脑小白就显得很麻烦，所以我希望有个软件能更加智能管理唤醒和睡眠。

## 零代码应用开发之旅

首先将需求转化为功能点，我们也可以让Cursor来帮我们，不过我本身就有思路。

1. 网页操作，打开网页，就可以唤醒电脑
   - 在网页打开期间，电脑不休眠
   - 网页关闭后，电脑自动休眠
   - 网页能显示有哪些网页客户端在唤醒电脑
2. 网页还是有些麻烦，能不能按需唤醒，对用户透明
   - 例如：用户点开远程桌面连接时唤醒，关掉远程桌面连接时休眠
   - 这个功能我叫做JIT WOL，即Just In Time WOL，即时唤醒

这里我先贴一下零代码的情况下的产品效果，左图是控制面板网页，右图是Mac平台的客户端，它们的用处，且看接下来的内容

![1736303698489](https://fliaping-blog.oss-rg-china-mainland.aliyuncs.com/storage/2025-01-08/22-12/1736303698489.png)

### Cursor功能介绍

在实现需求前，我们先了解下Cursor的几个主要功能。

1. 代码补全
   - 这个不用多说，各家Code Copilot都有这个功能，就看谁的补全更准确，从我使用过的Cursor、 Aone Copilot 、CodeFuse、通义灵码 来看，Cursor 的补全更准确，它的补全范围更广，例如修改一个地方之后它会找到下一个要改的地方，比较直观的感觉就是：一直Tab一直爽
2. 代码解释
   - 对于代码片段的解释这没什么难得，不用工具，直接丢给大模型也能解释的比较清楚，但对于项目的解释，就需要感知整个项目的上下文，通常叫做代码库的问答能力，Cursor会预先对整个代码库进行索引，然后在问答时对问题拆解后，会去查询索引，根据索引查询结果给出回答，尤其是需要从多文件中获取的知识，准确率有很大的提升，给人的感觉是对项目全局有一定的把控。
3. 代码生成
   - 直接用大模型也可以生成代码，但在生成整个项目的场景下，直接用大模型Chat的交互显然效率比较低。但Cursor的Composer功能，可以直接基于原代码进行修改，修改结果显示为diff视图，尤其是对于一些复杂逻辑的代码生成，Composer可以对多个文件进行修改，然后一键Apply，大大提高开发效率。

目前Cursor的面板有三个功能：

![1736250992288](https://fliaping-blog.oss-rg-china-mainland.aliyuncs.com/storage/2025-01-08/22-12/1736250992288.png)

1.Chat：这是每个Copilot都有的功能，在Chat功能中，Cursor也可以直接一键Apply代码，直接生成文件或修改代码，但是需要自己一个一个代码块去点击。
2.Composer：这是Cursor的特色功能，和整个编码过程融合的更好。有normal和agent模式，normal模式需要人介入的情况比较多，agent模式是更加自动化，会调用一些工具在系统上执行，例如判断生成的代码是否正确，agent直接执行命令，看执行日志，然后自动修改，用户只要点点是否接受，非常方便。
3.Bug Finder：这个功能是新出的，是按次付费的，有fast和smart模式， fast是免费的，smart每次竟然要2.82刀，太贵了我没体验，估计是用的o1这样的推理模型，fast模式应该用的普通模型

### GreenWake Bridge模块开发

这个模块就是我们前面提到需求的主要功能：远程唤醒与端口转发工具，实现唤醒管理端和即时唤醒

PS: 在这个模块中我刚开始用的Chat模式，而后开始使用Composer 的normal模式，此时我还没发现有一个Agent模式，这个确实给我带来了惊喜，后面会讲到

#### 第一步：生成前端页面

第一条Promot是生成前端的页面，如下:

```plaintext
生成一个前端页面，页面功能是对远程PC的休眠控制
1. 展示远程PC的状态：在线还是离线，并且提供一个是否保持远程PC唤醒状态的按钮，默认是打开的
2. 展示打开这个页面的客户端信息，包括平台，浏览器，等可以标识客户端的所有信息
3. 后端支持服务转发功能，页面展示目前激活的转发通道，包括目标服务的ip和端口
参考后端提供的服务接口如下：
1. 远程pc的状态接口，参数接受是否保持唤醒
2. 打开这个页面的客户端信息查询接口
3. 转发功能激活通道的信息查询接口
```

看看Cursor生成的结果：
![1736236305568](https://fliaping-blog.oss-rg-china-mainland.aliyuncs.com/storage/2025-01-08/22-12/1736236305568.png)

可能感觉和直接使用大模型，或者和其他的Copilot没什么区别，不过这是最基础的功能，点击代码块右上角的Apply按钮，就直接生成文件。

#### 第二步：生成Mock接口

这里我改用Composer，因为前面我使用Chat模式发现跟直接用大模型没大的区别，虽然可以方便一点，但感觉还是不够智能，所以改用Composer，之前就听说Composer很厉害，那么接下来看看

![1736237208510](https://fliaping-blog.oss-rg-china-mainland.aliyuncs.com/storage/2025-01-08/22-12/1736237208510.png)

可以看到，第一个图的对话把mock需要的文件都生成出来了，命令行也可以点右上角的Run直接运行。不过生成出来的代码有很多错误，后面几个对话全是在修复代码的错误，经过几次修改，代码已经没有IDE静态检查的错误了。是不是觉得还挺麻烦，正确率也没有很高，不过Cursor做的比较好的点是和IDE深度整合，这些错误编辑器提示之后，一个点击就开始解决了，如下图类似

![1736237562245](https://fliaping-blog.oss-rg-china-mainland.aliyuncs.com/storage/2025-01-08/22-12/1736237562245.png)

点击 `Fix in Composer` 会把编辑器的错误提示用预置的Promot包起来，丢给大模型

```plaintext
For the code present, we get this error:
[错误信息]
How can I resolve this? If you propose a fix, please make it concise.
```

#### 第三步：运行前端页面看看

我对前端只是略懂，不想费神去看它生成的代码，也不想要不想陷入复杂的细节之中，那么让它自己检查吧

![1736238131290](https://fliaping-blog.oss-rg-china-mainland.aliyuncs.com/storage/2025-01-08/22-12/1736238131290.png)

它后面做了4步检查，都是必要并且很正确的修改，所以在功能完成到一定程度，时不时就要让它自己检查，然后自己修复，这样就减少了后续：「发现报错->点击修复->生成修复」 这样很多次的循环。

我们按照它的要求执行命令，发现有错误，把错误丢给它，又是卡卡一顿改，反正我也不懂，无脑Apply All，有错误就让它解决。改了一个错误后就可以运行了，页面出来了，然后我要做的就是看看效果，哪里不满意，再丢给它，让它改。

![1736238950934](https://fliaping-blog.oss-rg-china-mainland.aliyuncs.com/storage/2025-01-08/22-12/1736238950934.png)

总之就是各种提要求，让它去修改，实现自己想要的功能，然后看看效果，不满意再改，此时我化身为一个无情的业务方，指挥着Cursor去实现我想要的功能。

#### 第四步：生成后端代码

前端页面已经可以正常工作了，接下来就是后端代码，这里我选择的是Go语言，因为我不懂，就是要看看它在我不懂的领域，会不会把我带到沟里

![1736239678814](https://fliaping-blog.oss-rg-china-mainland.aliyuncs.com/storage/2025-01-08/22-12/1736239678814.png)

有些基础的方法，例如检查主机在线状态、WOL唤醒，我之前写过，所以直接让它直接参考，让后让他设计后端项目的目录结构，完成对应的代码。可以看到我确实是不懂go的，但是一个软件项目该是什么样我是知道的，例如一个项目一般都需要一个依赖管理器，如果没有用这个提示词，可能要走不少弯路，可以说专业的知识是很重要的，在使用大模型时，专业的知识相关的提示词的得到的结果的准确率会更高。

![1736240800049](https://fliaping-blog.oss-rg-china-mainland.aliyuncs.com/storage/2025-01-08/22-12/1736240800049.png)

我让它和参考代码进行对比，看看功能是否一致。要重点看它改动后的总结，如果改动太多或者自己也不太懂，看总结就可以发现有哪些是不符合预期的，这里它的改动主动加了主机状态60秒的缓存，这肯定不是我们期望的，所以后面需要让它改过来。

#### 第五步：前后端代码对齐

生成的后端代码，能否直接适配前端，在后端代码基本功能完成后，进行一次前后端对齐，如下：
![1736241515290](https://fliaping-blog.oss-rg-china-mainland.aliyuncs.com/storage/2025-01-08/22-12/1736241515290.png)

后面就是根据自己验证的情况，发现问题，让Cursor去修改，直到功能完成。这里截图省略了，因为整个过程还是比较多的，每一个功能点一般需要2-7次迭代才可以符合预期。其实也没有预想中的那么容易，但在Cursor中效率已经提升了很多，做重要的是释放了精力，不用去纠结代码的细节，只需要关注功能点。

#### 第六步：更多功能的完善

我没有一次性把一个模块的功能生成完再做另一个，而是先生成基本功能，走通链路流程，然后完善功能。这样的方式首先是遵循产品的最小化原则，快速实现一个简单可用的功能，原因有两个：

1. 第一次生成一个稍微复杂的项目，可能会有很多问题，不一定成功，先快速验证
2. 如果第一次把一个模块搞完整，后续的如果发生变化，重新生成的代码会比较多，这样就会浪费很多时间
3. 最小化链路的框架有了之后，作为后续生成的上下文，更容易将结果约束在正确的方向

![1736243118689](https://fliaping-blog.oss-rg-china-mainland.aliyuncs.com/storage/2025-01-08/22-12/1736243118689.png)

后面功能完善的过程还是比较长的，中间也有发现之前的设计不合理，更改设计的情况，如果是我们开发同学，心里肯定非常不乐意，也会给出各种理由说明改设计带来的困难（狗头），但Cursor不会，大模型没有情绪，最多浪费的是自己的时间哈哈。但这里我们也可以看到提高效率的另一种方式，就是要预先设计好，尽量先做设计，把设计的细节通过大模型梳理清楚，这样生成的质量好好很多，并且减少了后续的迭代次数。

后续实现的功能有：

1. 支持多台主机
2. 转发通道状态、客户端列表、客户端计数等
3. x86和arm架构的Docker镜像构建

#### 模块小结

到这里项目的第一部分GreenWake Bridge已经完成，部署到自己家里的一个低功耗&持续运行的设备上就可以了，例如路由器、树莓派、NAS等 ，这样就可以实现对家里其他主机的远程唤醒和休眠的管理， 也实现了无感唤醒的能力，只要通过Bridge转发的服务，就能实现请求时唤醒，结束后睡眠。(因为服务部署在家里的设备，还有个内网穿透的需求， 方法1：可以申请公网IP+DDNS，方法2：内网穿透软件或服务，例如frp或nps [办公设备可不能用])

### GreenWake Guard模块开发

有了Bridge，就可以实现对家里其他主机的远程唤醒和休眠的管理， 也实现了无感唤醒的能力，为什么需要Guard模块呢？

1. Windows系统对于WOL唤醒包的响应，来源于主板的支持，系统被唤醒后，再收到WOL唤醒包是没有任何处理的，也没有重置睡眠定时器，导致到了时间还是会睡眠，再收到唤醒包然后又唤醒，这样就导致服务频繁的中断和恢复（不过对于远程桌面连接，Windows系统会禁用自动睡眠，所以可以正常使用）
2. 其他系统也有类似的问题，所以需要一个守护进程来保证服务过程中的稳定性，确保服务不会因为意外睡眠中断

```text
让我们完成另一个模块的功能，这个功能是在远程PC上运行的后台服务，这个服务的作用是保持系统不要休眠
1. 服务有一个托盘图标，可以选择保持唤醒的策略：唤醒包唤醒（没收到唤醒包可以正常休眠，这是默认策略，计时唤醒到时间后切换到当前策略）、永久唤醒（一直不能休眠，除非策略切换到关闭）、计时唤醒（可以选择x分钟或者x小时内保持唤醒）
2. 当服务监听到持续的唤醒包时保持系统不睡眠，当N分钟后没收到唤醒包，并且手动策略是「唤醒包唤醒」则可以让系统休眠
3. 要同时支持 macOS、Windows10-Windows11、Linux 三个平台，包括保持唤醒功能、托盘图标服务、以及三个平台的软件安装功能
4. 建议使用跨平台方案，尽量让代码不用关注不同平台的差异
5. 唤醒结束后系统要进入睡眠用于节能，有两种模式：模式1是系统自动睡眠，这种适用于系统能自动睡眠的场景，模式2是服务主动触发睡眠
```

#### Agent模式带来的惊喜

这次我用上了Composer的Agent模式，前文也介绍了这是一种更加自动化的模式

![1736254755876](https://fliaping-blog.oss-rg-china-mainland.aliyuncs.com/storage/2025-01-08/22-12/1736254755876.png)

前两个图跟Chat类似，但是注意后两个图，可以看到它在进行自动化的迭代（目前自动迭代最大次数是25次）。例如：

1. 在代码修改之后，会调用IDE的分析工具，图中的 `Found lints`，就是IDE的静态检查工具的结果，第三图可以看到它根据lints继续进行修复，整个过程我是没有参与的，直到 `No linter errors` 才算暂停
2. 在图三最开始，可以看到调用删除工具删除无用的文件，不过在删除之前需要确认
3. 在图四，我们可以看到它直接执行命名，根据命令结果来进行调整，例如目录错误了就会自动修改命令后再执行，根据命令的结果修改代码。当然命令的执行也是需要用户确认，不然删错就麻烦了

![1736256800866](https://fliaping-blog.oss-rg-china-mainland.aliyuncs.com/storage/2025-01-08/22-12/1736256800866.png)

1. 第一个图可以看到它会主动调用工具搜索代码索引，找到和当前问题相关的代码文件作为上下文，这也是Agent模式比较好的一个特性。
2. 第二个图可以看到它调用读文件工具，去检查文件中的代码

在Agent模式下，根本没有切换窗口的必要，自己就像一个领导，等它干完活，然后点个审批通过就行，不符合预期就打回重改，感觉很爽，完全沉浸在PUA的快乐中。接下来让我们享受这美妙的过程吧，啊不对，让我们沉浸在沮丧的代码中吧

![1736256914907](https://fliaping-blog.oss-rg-china-mainland.aliyuncs.com/storage/2025-01-08/22-12/1736256914907.png)

但是后面的图真的很让人沮丧，一个简简单单的要求它根本理解不了，经过很多轮的尝试，我记得是超过25轮的上限了，还是没能解决，此时就要拿出PUA大招，让Chatgpt和Claude两位员工互相批判，甚至还需要找找外援，让DeepseekV3也来帮帮忙(Agent模式目前只能使用gpt-4o和Claude)

#### 模块小结

因为这个模块是跨平台客户端，逻辑也比较复杂，涉及到状态的转移，所以遇到了很多的问题，下面是Cursor生成的状态图，非常准确的表达了这个模块的主要功能

![1736322212100](https://fliaping-blog.oss-rg-china-mainland.aliyuncs.com/storage/2025-01-08/22-12/1736322212100.png)

## 实践总结

整个项目一共花了快三天时间，花费了1500个请求的额度，整体框架其实很快就搞好了，最费时间的是细节的调整，出现过好几次把我验证过的功能改掉的情况，又要重新来修复。如果是对于领域的熟练工，用Cursor生成的整体效率其实也就快1-3倍，但是对于一个领域外的人，加上学习时间，这个效率的提升绝对是10倍以上的。

### 智能编码的能力

能力自不用多说，经过前面的文章，大家应该已经看得出来，这里简单总结两个要点：

1. 效率的提升，可以生成代码，多轮迭代，修复问题等，减少了很多劳动
2. 更多的可能性，帮助个人或组织实现之前不可能的事情

### 当前智能编码的局限与应对

1. 大模型对代码的解释能力有限，在修改一个功能给时会偷偷把无关的东西修改掉，导致之前验证好的功能遭到破坏
   - ✅ 改动某个具体功能加上限定词，例如：「不要修改其他功能」、「保持最小化更改」
2. 大模型生成代码的准确率不高，需要反复修改
   - ✅ 使用Agent模式，通过自动迭代，自动修复，看情况人工介入
3. 非常依赖详细的Promot描述，有些时候需要反复修改Promot，才能得到满意的结果
   - ✅ 没办法，在模型推理能力没有突破之前，只能靠各种技巧优化自己的Promot

### 使用技巧总结

本次实践中，我没有用比较复杂的Promot范式，基本都是直接描述需求点，所以有些时候效果没有那么好， 效率也比较低。

根据本次使用Cursor的经验，总结了几个使用技巧，希望对大家有所帮助：

1. ✅ 首先先定义好方案，确保自己的需求是明确、详细、尽量不会变的。（如果方案不确定的，可以让大模型帮助完善，先不要写代码）
2. ✅ 问题无法解决时，尝试换换模型，让不同的模型之间互相review，或者换成英语描述
3. ✅ 让大模型写代码时打印详细的debug日志，这样可以让大模型更容易发现问题
4. ✅ 让大模型进行多方验证，例如：前后端代码相互验证、单元测试验证、自己进行代码review等
5. ✅ 注意多提醒大模型改动的时候要谨慎谨慎再谨慎，不要把已经验证过的功能改掉了，所有和现存代码行为不一致的改动都要询问
6. ✅ 如果需要生成一个项目，可以先让大模型生成一个代码的框架，然后自己再逐步分模块完善，尽量让上下文的信息更加内聚

## 启示和未来

通过对最先进的编程辅助工具的探索，我发现自然语言真的可以成为更高层级的编程语言，从机器码到汇编再到高级语言，从面向过程到面向对象再到函数式，到现在的自然语言编程的雏形出现，编程向着平民化不断演进，成为每个人都可以使用的工具，当每个人都能制作应用满足自己个性需求，个人的能力会大幅扩展，这一定能大大提升整个人类社会的效率。

### 对当前工作的启示

虽然目前来看，智能编程还不能完全替代人类编程，但一些低级重复的编程劳动肯定会被替代，如果需求场景没有变化，那势必会带来编程劳动的减少，对于一部分人来说这不一定是好事。但技术的进步是不可阻挡的，我们要做的就是适应新的环境，并利用新的技术来提升自己的竞争力，让技术成为自己的助力，而不是担忧。

回归到工作，可以用能用的工具来提高效率，或者自己去创造工具，服务自己、服务业务。

### 对未来的思考

未来在科幻里都有，虽然有很多AI替代人类的担忧，但可以预见，未来需求端也一定会发生变化，很多新的需求会产生，利用新的工具，我们可以创造出更多现在难以想象的事情。至少人类目前还很落后，还窝囊在地球上生活、很多疾病也无法治愈、在灾难面前也无能为力、因为受限的资源斗的你死我活。

未来有很多事情需要去做，未来可期，让我们追随技术的浪潮，迎接新的挑战。

## 后记

实践先行，原理随后，且听下回原理分解
